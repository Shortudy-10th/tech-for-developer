## 운영체제

<details>

<summary>❓ 스레드의 생명 주기에 대해 설명해주세요.</summary>

💬 **답변**  

스레드 객체가 생성되는 경우 생명 주기를 갖게 되는데, 7가지(New, Runnable, Blocked, Running, Time Waiting, Waiting, Terminated)로 나눌 수 있다.

![image](https://github.com/Shortudy-10th/tech-for-developer/assets/39663810/1bbd9c44-0153-4af4-af71-972a7efe48ef)

**1. 신규(New):** 
- 스레드 객체가 생성되었지만 아직 시작되지 않은 상태
- `start()` 메서드가 호출되기 전

**2. 실행 가능(Runnable):** 
- 스레드가 실행을 위해 준비되었으나, 스케줄러에 의해 아직 선택되지 않은 상태 
- `start()` 메서드가 호출된 후

**3. 실행 중(Running):** 
- 스레드가 현재 실행 중인 상태
- CPU 스케줄러에 의해 선택되어 실행되는 중

**4. 대기(Blocked):** 
- 스레드가 실행 중지 상태에 있고, 특정 모니터 락을 획득하기를 기다리는 상태

**5. 시간 대기(Timed Waiting):** 
- 스레드가 특정 시간동안 대기하도록 지정된 상태
- Ex) `sleep()` 메서드에 의해 특정 시간 동안 대기할 경우

**6. 무한 대기(Waiting):** 
- 스레드가 다른 스레드의 특정 동작을 기다리는 상태
- Ex) 다른 스레드의 `notify()` 또는 `notifyAll()` 메서드 호출을 기다리는 경우

**7. 종료(Terminated):** 
- 스레드의 실행이 완료되어 종료된 상태
- 실행할 코드가 더 이상 없거나, 예외로 인해 종료되거나, 명시적으로 종료된 경우
</details>

--- 

<br> 

<details>

<summary>❓ 프로세스와 스레드의 차이에 대해 설명해주세요.</summary>

💬 **답변**  

![process_thread](https://github.com/Shortudy-10th/tech-for-developer/assets/87293724/d5128f39-3ff1-4a49-8a42-82affd9c76ac)

- 스레드가 모여 프로세스를 이루고, 프로세스가 모여 프로그램을 이룬다.

### 프로세스

<img width="693" alt="스크린샷 2021-03-07 오후 3 15 46" src="https://github.com/Shortudy-10th/tech-for-developer/assets/83208807/b14e2c43-6836-4f4f-84ef-0ec71db94db4">

- 메모리 상에서 실행 중인 프로그램
- 프로세스는 다른 프로세스와 독립적으로 존재
  - 하나의 프로세스에 충돌이 발생해도 다른 프로세스에는 영향을 주지 않음
  - 다른 프로세스와 메모리를 공유하지 않음
- 스레드에 비해 복잡한 IPC (Inter-Process Communication) 메커니즘을 필요

### 스레드

<img width="689" alt="스크린샷 2021-03-07 오후 3 49 40" src="https://github.com/Shortudy-10th/tech-for-developer/assets/83208807/5cf74e78-cace-4573-a4a0-2b66d3d83e55">

- 프로세스 안에서 실행되는 흐름 단위
- 프로세스가 점유한 메모리 공간에서 각 스레드는 공간을 공유
	- 서로의 메모리에 접근할 수 있다.
	- 하나의 스레드에 오류가 발생하면, 전체 프로세스와 해당 프로세스 내의 다른 스레드에 영향을 미칠 가능성이 있음

#### 프로세스는 자원을 공유하지 않지만 스레드는 자원을 공유한다

</details>

--- 

<br> 

<details>

<summary>❓ 스레드란 무엇이며, User Level Threads (사용자 레벨 스레드)와 Kernel Level Threads(커널 레벨 스레드)에 대해 설명해주세요.</summary>

💬 **답변**  

### 스레드(thread)
- 스레드란 프로세스가 할당받은 자원을 이용하는 실행의 단위로, 커널 스레드와 사용자 스레드로 나눌 수 있다.

> 사용자 레벨 스레드와 커널 레벨 스레드의 차이는 `누가 스레드를 관리하느냐`와 `어떻게 스레드가 실행되느냐`와 관련되어 있다.
 
![261014582-985e5b34-a53f-4b14-9328-0f9eafe2470f](https://github.com/Shortudy-10th/tech-for-developer/assets/83208807/9bc71043-2868-40d2-b285-f763f2bc8d6b)

### User Level Threads (사용자 레벨 스레드) 
- 운영체제가 멀티 스레드를 지원하지 않았을 때 사용하는 방법
	- 커널 외부에서 관리되는 스레드로, OS가 직접 관여하지 않음
- 해당 스레드는 라이브러리로 이루어짐(POSIX threads)
> 사용자 레벨 스레드의 특징
- 라이브러리가 직접 스케줄링과 작업에 필요한 정보를 처리해 컨텍스트 스위칭이 필요하지 않음(=오버헤드 적음)
- 사용자 레벨 스레드가 `블로킹 I/O` 또는 `페이지 폴트` 같은 이벤트에 의해 중지되었을 때, 해당 프로세스의 모든 스레드가 중단될 수 있음
   - 이는 OS가 스레드를 개별적으로 인식하지 못하기 때문
- 스레드 정보는 프로세스가, 프로세스 정보는 커널이 관리
- 1개의 커널과 여러 개의 스레드가 연결된 `N:1 모델`

### Kernel Level Threads (커널 레벨 스레드) 
- 커널 레벨 스레드는 커널 내부에서 관리
	- OS가 직접 스레드를 관리하기 때문에 각 스레드가 독립적으로 스케줄링될 수 있음

> 커널 레벨 스레드의 특징
- 스레드 생성, 삭제 등의 관리 작업이 커널 내부에서 수행되므로 시스템 콜을 통해 진행
	- 유저 모드와 커널 모드의 전환이 빈번하여 오버헤드 발생
- 각 스레드가 독립적인 스케줄링을 가져 하나의 스레드가 블로킹 상태에 놓여도 다른 스레드에 영향을 주지 않음
- 하나의 사용자 스레드와 하나의 커널 스레드가 연결되어 `1:1 모델`

> 사용자 레벨 스레드와 커널 레벨 스레드를 결합한 하이브리드 스레드 모델도 존재하며, 사용자 레벨 스레드와 커널 레벨 스레드를 연결하고, 서로의 장점을 최대한 살린 동시에 단점을 최소화하는 방향으로 작동한다.

</details>

--- 

<br> 

<details>

<summary>❓ 멀티 쓰레드의 동시성과 병렬성을 설명해주세요.</summary>

💬 **답변**  

**1. 동시성** 

- **`마치`** 동시에 실행되는 것처럼 보이는 것
- 싱글 코어에서 Multi Thread를 동작 시키기 위한 방식
-  Multi Tasking을 위해 ```여러 개의 스레드가 번갈아가면서 실행``` 되는 성질
- 멀티 스레드로 동시성을 만족 시킬 수 있는 것이지 동시성과 멀티 스레드는 연관이 없다.

**2. 병렬성**

- **`실제로`** 동시에 실행되는 것
- 멀티 코어에서 멀티 스레드를 동작시키는 방식
- ```한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행```되는 성질

![concurrent](https://github.com/Shortudy-10th/tech-for-developer/assets/87293724/b13394ac-f24f-4ea0-874f-71d4f9c3aee5)

</details>

--- 

<br> 

<details>

<summary>❓ Thread-Safe 라는 말은 무슨 의미인가요?</summary>

💬 **답변**  

- 두 개 이상의 스레드가 `race condition`에 들어가거나 같은 객체에 동시에 접근해도 연산 결과는 정합성이 보장될 수 있게 메모리 가시성이 확보된 상태

<details>

<summary>❓ 어떻게 Thread-Safe를 지킬 수 있을까요?</summary>

💬 **답변**  

Thread-Safe를 지키기 위한 방법은 여러가지가 있다.

#### 상호 배제 (Mutual Exclusion)

- 공유 자원에 하나의 스레드만 접근 가능하도록 세마포어/뮤텍스로 락을 통제하는 방법
  - 일반적으로 많이 사용
 > 뮤텍스 (Mutex)
![img1 daumcdn](https://github.com/Shortudy-10th/tech-for-developer/assets/83208807/7948c74e-348e-4963-869e-b52b13cad802)
- 공유 데이터에 대한 동시 접근을 제한하여 데이터 일관성을 보장
- 한 번에 하나의 스레드만 공유 리소스에 접근 가능
- 다른 스레드는 뮤텍스가 해제될 때까지 대기

> 세마포어 (Semaphore)
![img1 daumcdn](https://github.com/Shortudy-10th/tech-for-developer/assets/83208807/145057f7-84e8-49fc-8c7b-8eb47d605fbc)
- 공유 리소스에 동시 접근할 수 있는 스레드 수를 제한하여 데이터 일관성을 보장
- 계수 세마포어와 이진 세마포어로 나뉘며, 계수 세마포어는 동시에 여러 개의 자원을 사용할 수 있는 반면, 이진 세마포어는 한 번에 하나의 자원에 대해서만 사용 가능

#### 원자 연산 (Atomic Operation)
- 구성 요소 사이에서 불간섭 조건(실행 중에 외부 요인에 의해 변경되지 않음)을 만족하는 연산
- 스레드 간 경쟁 상황에서 데이터 일관성을 보장하고 동기화 오버헤드 감소
- 락이나 뮤텍스 없이 간단한 데이터 업데이트 또는 카운트 비트 작업을 할 때 사용

#### 스레드 지역 저장소 (Thread-Local Storage)
- 각 스레드에게 개별적인 데이터를 저장하는 메모리 영역으로, 전역 데이터에 대한 동기화 문제를 피할 수 있으며 쓰레드 간 독립적인 작업을 수행할 수 있음
#### 재진입성 (Re-Entrancy)
- 함수나 코드 블록이 여러 번 동시에 실행될 경우에도 안전하게 동작한다는 것을 의미. 
- 재진입 가능한 함수는 동시 호출에 영향을 받지 않도록 로컬 변수를 사용하거나, 락을 사용하여 데이터 접근을 제어하고 외부 변경 가능 요소를 제거하여 구현됨

</details>
</details>

--- 

<br> 
