# 운영체제 - CPU 스케줄링

<details>

<summary>❓ 스케줄링이란 무엇이며, 스케줄링이 필요한 이유는 무엇인가요?</summary>

### ❓ 스케줄링이란 무엇이며, 스케줄링이 필요한 이유는 무엇인가요?

<br>

* **스케줄링이란?**

컴퓨터 시스템의 전반적인 성능과 안정성을 높이고, 사용자의 만족도를 향상 시키는 데 기여한다. 
스케줄링 알고리즘에 따라 선점, 비선점 스케줄링 등의 방법이 있으며, 
시스템 목적과 요구에 맞게 적절한 스케줄링 전략을 선택하는 것이 중요하다.

<br>

* **스케줄링이 필요한 이유**

> **자원 사용 효율성**
- 프로세서, 메모리 및 I/O 자원과 같은 한정된 시스템 자원을 최대한 효율적으로 사용하도록 프로세스를 관리함으로써 전반적인 시스템 성능을 향상 시킬 수 있다.

> **공정성 및 사용자 만족도**

- 여러 프로세스가 동시에 실행되어야 하는 환경에서 스케줄러는 공정한 자원 배분이 이루어지도록 관리하여 운영 체제가 다양한 작업을 원활하게 처리할 수 있게 한다.

> **반응 시간 개선**

- 인터랙티브한 시스템의 경우 사용자 요청에 대해 적절한 반응 시간을 줄이기 위해 스케줄링이 필요하다. 
- 스케줄링을 통해 시스템은 사용자 요청을 적절한 순서로 처리하고 사용자가 원활한 응답을 받을 수 있도록 지원한다.


> **작업량 최적화**

- 시스템에서 처리되는 프로세스 작업량을 최대한 높이기 위해 스케줄링이 사용된다. 고성능 시스템에서는 동시에 여러 프로세스가 실행되어야 하므로 스케줄링이 핵심적인 역할을 한다.

</details>

<br>

---

<br>

<details>

<summary>❓ 선점 스케줄링과 비선점 스케줄링의 차이를 설명해주세요.</summary>

### ❓ 선점 스케줄링과 비선점 스케줄링의 차이를 설명해주세요.

<br>

![image](https://github.com/Shortudy-10th/tech-for-developer/assets/39663810/9da9e4ee-211d-4cc9-81aa-a3c0170c0205)

* **선점 스케줄링(Preemptive Scheduling)**
  * 선점 스케줄링은 현재 실행 중인 프로세스가 완료되기 전에 다른 프로세스가 그 프로세스를 중단하고 CPU를 차지할 수 있는 스케줄링 방식
  * 더 높은 우선 순위의 프로세스가 도착하면 현재 실행 중인 프로세스를 중단시키고 새로운 프로세스를 실행
  * 시스템의 응답 시간을 개선하고, 더 공정한 자원 분배를 제공
  * 실시간 운영체제, 대화형 시스템 등에서 주로 사용

* **비선점 스케줄링 (Non-Preemptive Scheduling)**
  * 비선점 스케줄링은 한 번 CPU를 할당받은 프로세스가 종료되기 전까지 다른 프로세스가 그 프로세스를 중단시킬 수 없는 스케줄링 방식
  * 현재 실행 중인 프로세스가 완료될 때 까지 다른 프로세스가 대기 필요
  * 구현이 상대적으로 쉬움
  * 배치 처리 시스템, 간단한 임베디드 시스템에서 주로사용

</details>

<br>

---

<br>

<details>

<summary>❓ 비선점형 스케줄링 알고리즘에 대해 설명해주세요.</summary>

### ❓ 비선점형 스케줄링 알고리즘에 대해 설명해주세요.

* 어떤 프로세스가 CPU를 할당받아 실행 중이라면 그 작업이 끝날 때까지 기다리는 비선점형
* 예시
  * FCFS 스케줄링
  * SJF 스케줄링
  * HRN 스케줄링

<br>

<details>

<summary>FCFS 스케줄링</summary>

<img src="https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/2407f21d-43c6-4b8a-98c2-665a92a05aca" width="600">

* First Come First Served
* 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식
  * 선입선출 스케줄링, FIFO 스케줄링
* 초기 일괄 작업 시스템에서 사용됐음
* 큐가 하나라 모든 프로세스의 우선 순위는 동일함
* 단순하고 공평함
* 단점
  * 처리 시간이 긴 프로세스가 CPU를 차지하면 무작정 기다려야 하는 콘보이 효과(or 호위 효과)로 인해 효율성 떨어짐
  * 현재 프로세스가 입출력 요청이 많으면 그동안 CPU가 아무 일도 하지 않고 낭비됨

* 성능

  <img src="https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/bc07a4e7-9e5b-494d-b16d-f8050129cd3a" width="300">

  <img src="https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/cf8143b8-f9af-4177-9308-3db3b900a945">

* 평균 대기 시간 : `(0 + 27 + 42) / 3 = 23`

</details>

<br>

<details>

<summary>SJF 스케줄링</summary>

<img src="https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/ff22ba44-6506-4f04-b3c3-afc152274281" width="500">

* Shortest Job First
* 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
  * 최단 작업 우선 스케줄링, SPF 스케줄링
* FCFS 스케줄링의 콘보이 효과를 완화해 시스템 효율성 높임
* 단점
  * 프로세스의 종료 시간을 예측하기 어려움
    * 현대 프로세스는 사용자와의 상호작용이 빈번하기 때문
  * 공평하지 못함
    * 실행 시간이 작은 것을 우선하기 때문에 중간에 더 짧은 프로세스가 계속 추가된다면 실행 시간이 긴 프로세스는 끝까지 실행되지 못하는 아사 현상 혹은 무한 봉쇄 현상이 발생함
    * 완화 방법
      * 에이징 : 프로세스가 양보할 수 있는 상한선을 정하는 것, 양보할 때마다 1씩 증가해서 상한선 도달하면 무조건 실행
* 단점으로 인해 잘 사용하지 않음

* 성능

  <img src="https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/008e5fea-5b5d-4a8a-b3d5-5470baba6490" width="300">

  <img src="https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/c08dc5ec-722a-41d6-b68a-03483b8a12b1" width="600">

* 평균 대기 시간 : `(0 + 24 + 36) / 3 = 20`

</details>

<br>

<details>

<summary>HRN 스케줄링</summary>

* Higest Response Ratio Next
* SJF 스케줄링에서 발생하는 아사 현상을 해결하기 위해 만들어진 비선점형 방식
  * 최고 응답률 우선 스케줄링
* 서비스를 받기 위해 기다린 시간과 CPU 사용 시간을 고려해 스케줄링함
   * 우선순위 = `대기시간 + CPU 사용시간 / CPU 사용시간`
* SJF 스케줄링에 비교하면 아사 현상을 해결했다는 장점이 있지만, 여전히 공평성이 위배되어 잘 사용되지 않음

* 성능

![Untitled 9](https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/f0f9af02-7296-4cba-a256-4b49b56d964a)

</details>

<br>

</details>

<br>

---

<br>

<details>

<summary>❓ 선점형 스케줄링 알고리즘에 대해 설명해주세요.</summary>

### ❓ 선점형 스케줄링 알고리즘에 대해 설명해주세요.

<br>

* 어떤 프로세스가 CPU를 할당받아 실행 중이라도 작업을 중단시키고 CPU를 강제로 뺏을 수 있는 알고리즘
* 예시
  - 라운드 로빈 스케줄링
  - SRT 스케줄링
  - 다단계 큐 스케줄링
  - 다단계 피드백 큐 스케줄링

<br>

<details>

<summary>라운드 로빈 스케줄링</summary>

<img src="https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/064960e9-2b44-47eb-93c4-b4769102834a" width="500">

* 한 프로세스가 할당받은 시간(타임 슬라이스) 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가는 선점형 방식
* 가장 단순하고 대표적인 방식으로, 모든 프로세스가 작업을 완료할 때까지 순환하며 실행됨
* FCFS 스케줄링과의 차이는 타임 슬라이스가 존재한다는 것
* 타임 슬라이스의 크기와 컨텍스트 스위칭
   * 평균 대기 시간이 비슷하다면 FCFS 스케줄링보다 비효율적인데, 이유는 프로세스 간의 컨텍스트 스위칭으로 인한 오버헤드가 있기 때문.
   * 컨텍스트 스위칭으로 인한 추가 시간을 고려해 타임 슬라이스의 크기를 결정해야 함
      * 큰 경우 : 너무 크면 FCFS와 다를 바 없음
      * 작은 경우 : 너무 작으면 컨텍스트 스위칭이 너무 자주 일어남

* 성능

![Untitled 10](https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/4adaa686-d5c4-445b-9924-659c56b36c1b)

</details>

<br>

<details>

<summary>SRT 스케줄링</summary>

<img src="https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/52c01405-118d-4a65-bb5a-0247650bb5b8" width="500">

* SJF 스케줄링과 라운드 로빈 스케줄링의 혼합
* 기본적으로 라운드 로빈 스케줄링을 사용하나, CPU 할당받을 프로세스 선택 시 남아 있는 작업 시간이 가장 적은 프로세스를 선택
  * 최소 잔류 시간 우선 스케줄링
* 단점
  * 현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 컨텍스트 스위칭을 해야 해서 SJF 스케줄링에는 없는 과정이 추가됨
  * SJF 스케줄링과 마찬가지로 프로세스 종료 시간을 예측하기 어렵고, 아사 현상이 발생함
* 잘 사용 안 함

* 성능

![Untitled 11](https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/28ad5f95-51d5-4cad-bd5d-ad86a7b4cee7)

</details>

<br>

<details>

<summary>다단계 큐 스케줄링</summary>

<img src="https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/e70d2550-7a05-4e69-9b20-f51ac78155de" width="500">

* 우선순위에 따라 준비 큐를 여러 개 사용하는 방식
  * 우선순위 별로 큐가 존재
  * 각 큐는 라운드 로빈 스케줄링 방식으로 돌아감
* 고정형 우선순위를 사용함
* 우선순위에 따라 다양한 스케줄링이 가능한 선점형 방식
  * 우선순위 높은 순으로 실행 및 우선순위에 따라 타임 슬라이스 조절 가능 등
  * 프로세스의 우선순위와 작업 형태를 고려해 스케줄링이 가능함
* 우선순위가 높은 상위 큐의 프로세스 작업이 끝날 때까지 하위 큐 프로세스는 작업 할 수 없음
  * 이런 문제로 인해 다단계 피드백 큐 스케줄링이 나옴

</details>

<br>

<details>

<summary>다단계 피드백 큐 스케줄링</summary>

<img src="https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/ce94b6ad-6484-4280-a058-7444ede53084" width="500">

* 다단계 큐 스케줄링의 문제를 보완한 방식으로, 변동 우선순위 사용
* 다단계 큐와 달리, CPU를 사용하고 난 프로세스의 우선순위가 낮아짐
  * CPU 사용이 끝난 후 기존 큐가 아닌, 한 단계 낮은 큐로 들어감
  * 단, 커널 프로세스의 경우 일반 프로세스의 큐에 삽입되지 않음
* 우선순위에 따라 타임 슬라이스 크기가 다름
  * 우선순위 낮은 큐의 타임 슬라이스가 더 큼
  * CPU를 얻을 확률이 더 낮기 때문에 한번 할당받으면 오래 사용할 수 있게 하기 위함
  * 우선순위가 가장 낮은 큐의 타임 슬라이스는 거의 무한대로, 결국 마지막 큐의 경우 FCFS 스케줄링으로 동작함
* **오늘날 운영체제가 일반적으로 사용하는 스케줄링 방식**

</details>

<br>

</details>

<br>

---

<br>

<details>

<summary>❓ 우선순위 스케줄링에 대해 설명해주세요</summary>

### ❓ 우선순위 스케줄링에 대해 설명해주세요

<br>

**우선순위 스케줄링**

* 프로세스는 중요도에 따라 우선순위를 가지는데, 이를 스케줄링에 반영한 것
  * 우선순위를 어떻게 정하느냐에 따라 다양한 방식으로 구현 가능 -> 선점, 비선점 둘 다 가능
* 고정 우선순위 알고리즘
  * 한번 우선순위를 부여받으면 종료될 때까지 유지
  * 구현이 단순하나, 시스템 변동 사항 반영이 안 돼 효율성 떨어짐
* 변동 우선순위 알고리즘
  * 일정 시간마다 우선순위가 변함
  * 복잡하지만, 시스템 상황을 반영해 효율적인 운영 가능
* 시스템 효율성이 아닌 프로세스 중요도에 따라 우선순위를 정하는 이유 : 커널 프로세스와 일반 프로세스가 같은 우선순위라고 하면 일반 프로세스를 실행하느라 커널 프로세스가 제 역할을 못 할 수 있기 때문
* 단점
  * 우선순위가 높은 프로세스에 먼저 CPU를 할당하기 때문에 아사 현상이 발생할 수 있음
  * 준비 큐의 프로세스 순서를 무시하고 프로세스 우선순위에 따라 매번 바꿔줘야 해서 오버헤드 발생

* 예시 : FCFS 스케줄링에 우선순위 적용했을 때의 성능

<img src="https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/cbf9f2e8-03c5-4384-a7ba-abdcf29aad29" width="600">

</details>

<br>