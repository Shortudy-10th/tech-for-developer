# Java 2일차

<details>

<summary>❓ 추상 클래스와 인터페이스의 차이점에 대해서 설명해주세요.</summary>

### ❓ 추상 클래스와 인터페이스의 차이점에 대해서 설명해주세요.

#### 추상클래스는 추상메소드를 하나 이상 가지는 클래스이다.

- 그렇지 않은 경우도 있다. 하지만 일반적으로는 추상메소드를 포함한다.
- 위 조건을 만족하면 다른 클래스와 동일하게 다양한 변수나 함수를 가질 수 있다.
- 인스턴스를 생성할 수 없다.
- extends를 통해 상속받는다.
- 다중 상속이 불가능하다.

#### 인터페이스는 모든 메소드가 추상메소드여야 한다.

- 자바8로 올라오면서 default 키워드를 사용하는 구현 메서드를 가질 수 있지만, 꼭 구현하지 않아도 되는 메서드이다.
- 변수를 가질 수 없고 상수(public static final)만 가질 수 있으며, 모든 클래스와 - - 상수의 접근제한자는 public이다.
- 역시 인스턴스를 생성할 수 없다.
- implements를 통해 상속받는다.
- 다중 상속이 가능하다.

- <details>

<summary>❓ 추상 클래스와 인터페이스의 사용 용도는 어떻게 다른가요? </summary>

추상 클래스는 자식 클래스에서 공통적으로 사용할 부분은 미리 구현해놓고, 특정 부분은 오버라이딩하게 함으로써 공통 기능에 대한 코드의 중복을 줄이는 목적이 강하다. 따라서 클래스를 확장해나가는 느낌으로 사용한다.
반면에 인터페이스는 자식 클래스에게 일종의 강제성을 강요한다. 즉, 인터페이스는 자식 클래스들이 구현해야할 메소드들의 정의를 명시하고, 그 메소드들을 구현토록 한다. 이를 통해 서로 다른 클래스가 특정 동작을 공통적으로 수행하도록 하고 싶을 때 사용할 수 있다.

</details>

</details>

<br>

---

<br>

<details>

<summary>❓ 객체 지향 프로그래밍의 4가지 특징에 대해서 설명해주세요.</summary>

### ❓ 객체 지향 프로그래밍의 4가지 특징에 대해서 설명해주세요.

![OOP 4가지 특징](https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%EC%BA%A1%EC%8A%90%ED%99%94-%EC%B6%94%EC%83%81%ED%99%94-%EC%83%81%EC%86%8D-%EB%8B%A4%ED%98%95%EC%84%B1.png?resize=750%2C475&ssl=1)

- **캡슐화 (Encapsulation)**

  - 캡슐화는 객체의 상태와 행동을 하나로 묶고, 객체의 상태를 외부에서 직접 접근할 수 없게 하여 내부 구현을 숨기는 것을 말한다. 이를 통해 객체의 내부 상태를 보호하고, 외부에서는 해당 객체의 메서드를 통해서만 상태를 변경할 수 있도록 제어한다.

- **상속 (Inheritance)**
  - 상속은 한 클래스의 특성(속성과 메서드)을 다른 클래스가 물려받을 수 있게 해준다. 상속을 통해 코드의 재사용성을 높이고 중복을 최소화할 수 있으며, 기반 클래스의 변경이 파생 클래스에 자동으로 반영되므로 유지보수가 용이해진다.
- **다형성 (Polymorphism)**
  - 다형성은 하나의 인터페이스나 부모 클래스를 공유하는 여러 클래스의 객체가 동일한 메서드 호출에 대해 각각 다르게 반응할 수 있게 하는 특징이다. 이를 통해 코드의 유연성과 확장성을 증가시키며, 클래스 간의 결합도를 낮출 수 있다.
- **추상화 (Abstraction)**
  - 추상화는 객체의 특징 중 중요한 부분에만 집중하고 불필요한 세부 사항은 생략하는 것을 말한다. 추상화를 통해 시스템의 복잡도를 줄이고 유지보수를 용이하게 할 수 있다.

<details>
<summary> 
❓ 객체 지향 프로그래밍 5대 원칙에 대해 설명해주세요.
</summary>

**SOLID**

- SRP(단일 책임 원칙) : 하나의 클래스는 하나의 책임만 가져야 한다. 무언가 변경할 때, 그로 인한 파급 효과가 적을수록 잘 지킨 것. 하나의 클래스가 많은 책임을 가질수록 해당 클래스를 변경했을 때 다른 것도 함께 수정하게 되기 때문이다.

- OCP(개방-폐쇄 원칙) : 확장에는 열려 있고, 변경에는 닫혀 있어야 한다는 원칙. 다형성을 활용해 구현체는 바꾸더라도 다른 코드는 전혀 바꿀 필요 없는 일이 이에 해당한다.

- LSP(리스코프 치환 원칙) : 프로그램의 정확성을 깨뜨리지 않고 상위 타입의 인스턴스를 하위 타입의 인스턴스로 바꿀 수 있어야 한다는 원칙. 이 원칙을 지키지 않을 경우, 예를 들어 인터페이스에서 걷기를 두 다리로 걷기로 해놨는데, 하위 타입에서 두 팔로 걷기로 구현해버리면 문제가 생기게 된다.

- ISP(인터페이스 분리 원칙) : 인터페이스를 만들 때 하나로 뭉뚱그려 범용성 있는 인터페이스로 만드는 게 아니라, 인터페이스를 사용할 클라이언트를 기준으로 최대한 분리해서 만들어야 인터페이스가 명확해지고, 대체하기도 쉬워진다.

- DIP(의존 역전 원칙) : 구현체가 아닌 추상체인 인터페이스에 의존해야 한다. 인터페이스에 의존할 경우에는 다른 구현체로 바꿀 수 있지만, 구현체에 의존하면 다른 구현체로는 바꿀 수 없기 때문이다.

</details>
</details>
<br>

---

<br>

<details>

<summary>❓오버라이딩과 오버로딩에 대해 설명해주세요.</summary>

### ❓오버라이딩과 오버로딩에 대해 설명해주세요.

![오버라이딩과 오버로딩](https://cdn.filestackcontent.com/nceX6qyTzq0BvcHQH8x2)

- **오버라이딩**
  - 부모클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하는 것이다.
  - 메소드의 이름, 매개변수, 리턴타입 등이 모두 동일해야 한다.
  - 자식 클래스에서 오버라이딩하는 메소드의 접근 제어자는 부모 클래스보다 더 좁게 설정할 수 없다.
  - 예외(Exception)는 부모 클래스의 메소드 보다 더 큰 예외를 throw할 수 없다.
    - e.g. 부모클래스에서 NullPointerException을 throw하는데 오버라이딩해서 Exception을 throw할 수 없다.
  - static메소드를 인스턴스의 메소드로, 또는 그 반대로 바꿀 수 없다.
  - 부모클래스의 메소드를 자식클래스에서 적절한 용도에 맞게 재정의해 사용할 때 오버라이딩을 활용할 수 있다.
- **오버로딩**

  - 같은 이름과 같은 타입을 반환하는 메서드의 매개변수만 다르게 여러 개 정의하는 것을 의미한다.
  - 메소드의 리턴 타입만 다르거나, 변수의 이름만 다르고 그 타입들은 동일하면 오버로딩을 할 수 없다.
    - 즉, 매개변수의 차이로만 재정의 할 수 있다.
  - 접근제한자는 자유롭게 지정할 수 있다.
  - 다양한 데이터 타입에 대해 동일한 동작을 하는 메소드의 경우 오버로딩을 하기 적절한 메소드이다.

    - e.g. sum(int a, int b), sum(double a, double b)

  <br/>
  <details> 
    <summary>
    ❓ 오버라이딩할 때 부모 클래스에서 정의된 static메소드를 자식 클래스에서 일반 메소드로, 또는 일반 메소드를 static 메소드로 바꿀 수 없는 이유에 대해 설명해주세요.
    </summary>

  - static 키워드가 붙는 경우에는 컴파일 시점에 객체가 생성되기 전에 메모리 영역에 올라가 결정.
  - overriding의 경우에는 런타임 시점에 사용될 메소드를 결정.
    따라서 부모클래스에 있는 static이 붙는 method를 자식클래스에서 overriding 하려는 경우, overriding이 되지 않고 hiding이 됨. static method는 클래스 수준에서 호출되기 때문에 자식클래스에서 overriding한다기 보다 오히려 별개로 존재하는 새로운 함수가 define되는 개념에 가까움.
  - 결국 overriding의 개념이 적용되지 않는다는 뜻.
    즉 호출되는 overriding 된 일반 method는 자식 버젼의 method이겠지만 static method의 경우 어디서(부모클래스인지, 자식클래스인지) 호출되는지에 따라 달라지는 현상이 발생함.
    이런 상황에서 부모클래스를 상속할 때 자식클래스가 static method를 일반 method로 바꾸는게 가능해진다면, static method를 일반 method로 변환하여 overriding한 자식클래스와 그렇게 안한 자식클래스에서 해당 method를 호출할때 동작차이가 발생함.
    만약 변환하여 overriding 하는 것이 가능하다면 아래에서

  ```java
  public Class Parent {
      public static void foo(){
          System.out.println("method of parent");
      }
  }

  public Class ChildA extends Parent {
      public static void foo() {
          System.out.println("method of child A");
      }
  }

  public Class ChildB extends Parent {
      public void foo() {
          System.out.println("method of child B");
      }
  }

  public static void main(String[] args) {
      Parent c1 = new ChildA();
      ChildA c2 = new ChildA();
      Parent c3 = new ChildB();
      c1.foo();
      c2.foo();
      c3.foo();
  }
  ```

  출력 :

  ```
  method of parent
  method of child A
  ??????????????????
  ```

  3번 line은 compile시점에 결정된 "method of parent"를 출력할지 runtime시점에 결정된 "method of child B"를 출력할지 애매모호해지는 상황이 발생됨.
  이런 상황을 방지하기 위해 변환하여 오버라이딩 하는것을 허용하지 않는 것으로 이해됨.
  </details>
  <br/>
  <details>
    <summary>
    ❓ 정적 바인딩과 동적 바인딩은 무엇이고, 어떤 장단점이 있는지 설명해주세요.
    </summary>

      바인딩이란 함수 호출 시 함수의 정의와 함수의 실제 구현부를 연결하는 것을 의미하며, 정적 바인딩과 동적 바인딩이 있다.
      - 정적 바인딩은 컴파일 타임에 실행될 함수가 결정됨
      - 컴파일시 값이 확정돼 안정적이고 실행 효율이 좋음
      - 오버로딩, private, final, static이 붙은 메소드는 정적 바인딩 대상
      - 동적 바인딩은 실행 타임에 실행될 함수가 결정됨
      - 메모리나 시간의 효율은 떨어지더라도 여러 상황에 유연하게 대처할 수 있음
      - 오버라이딩은 동적 바인딩 대상

  </details>

  </details>
  <br>

---

<br>

<details>

<summary>❓ String, StringBuilder, StringBuffer에 대해 설명해주세요.</summary>

### ❓ String, StringBuilder, StringBuffer에 대해 설명해주세요.

![String, StringBuilder, StringBuffer 차이](https://user-images.githubusercontent.com/64778589/258559568-83163231-fc62-4b1e-8953-bd0ac4b36e57.png)

> 공통적으로 자바에서 문자열을 다룰 때 사용하는 클래스들이다.

**String**

- reference 타입 객체인 문자열 클래스이다.
- reference 중에서 유일하게 premitive 타입처럼 new 없이 객체를 생성할 수 있다는 특징이 있다.
- 불변성이기 때문에 여러 군데서 String 객체를 참조하더라도 수정이 일어나지 않아 안전하다. 또한 같은 값일 경우 같은 객체를 사용하기 때문에 메모리 절약과 속도 향상에 이점이 있다.
  - 문자열을 변경하면 ( ex. String str = "test"; str = "abc") 새로운 객체로 만들며, 만약 문자열이 같다면 == 로 비교가 가능하다. 새로운 객체가 만들어지므로 문자열을 바꿀 때 마다 주소가 바뀐다, 하지만 해쉬충돌로 인해서 다른 문자열이라도 ==가 true가 나오는 경우가 있으므로, equals를 사용하는 것을 권장한다.

**StringBuilder**

- 문자열을 변경할 수 있는 클래스로 문자열을 조작할 때마다 새로운 객체를 생성하지 않는다. 하지만 쓰레드 세이프하지 않으므로 싱글스레드에서 사용하는 것이 좋다. 문자열을 변경해도 주소값은 바뀌지 않으며, 힙메모리에 올라간다.

**StringBuffer**

- StringBuffer는 StringBuilder처럼 문자열을 변경할 수 있는 클래스이다. 하지만 StringBuilder와는 달리 모든 메서드가 동기화되어 있어 멀티스레드 환경에서도 안전하다.

<details>
<summary>❓ object 의 equals와 == 와 String의 equals의 차이를 설명해주세요
</summary>

- object와 String 모두 == 은 두 참조가 같은 메모리 주소값을 가리키는지 비교합니다. 이 것을 '동일성 비교'라고 합니다.
- object의 equals는 ==과 같이 동일성 비교를 합니다. == 과 달리 오버라이드 하여 동등성 비교를 할 수도 있습니다.
- String의 equals는 두 문자열이 동일한 값을 가지고 있는지 확인합니다. 메모리상 위치가 달라도 내용이 같으면 'true'를 반환합니다. 이것을 '동등성 비교' 라고 합니다.
</details>

<details>
<summary>❓ String의 경우 hashCode가 같다면 equals한가요 ?
반대로 equals 가 true라면 hashcode가 같나요?
</summary>

- 해쉬코드가 같다고 해서 같은 객체가 아닙니다. 해쉬코드가 같은 경우에는 같은 문자열일 경우도 있지만 해쉬충돌 난 경우에 다른 문자열일 경우 해쉬코드가 같을 수 있습니다.
반대로 equals가 같다면 hashcode는 같습니다.
</details>

</details>
<br>

---

<br>

<details>

<summary>❓ 자바에서 스레드를 사용하기 위한 두 가지 방법에 대한 설명과 차이점을 알려주세요.</summary>

### ❓ 자바에서 스레드를 사용하기 위한 두 가지 방법에 대한 설명과 차이점을 알려주세요.

**Thread**

- Thread는 쓰레드 생성을 위해 Java에서 미리 구현해둔 클래스이다.

- Thread 클래스로 쓰레드를 구현하려면 이를 상속받는 클래스를 만들고, 내부에서 run()를 구현해야 한다. 그리고 start()를 호출하면 run()이 실행된다.

**Runnable**

- Runnable 인터페이스를 implements하는 방법
- Runnbale 인터페이스는 1개의 메소드 (run)만을 갖는 함수형 인터페이스이다.
  그렇기 때문에 람다로도 사용 가능하다.

> 보통 Runnable을 선호한다.
> Java의 extends의 상속 방식은 하나의 Class만 가능하기 때문에,
> 만약 Thread를 사용하기 위해 이 한 번의 상속을 사용한다면 Java의 장점인 상속 기능의 제한이 생기기 때문이다.
> 그리고 Thread 클래스를 상속 받으면 Thread 클래스에 구현된 코드들에 의해 더 많은 자원(메모리, 시간 등)을 필요로 한다.

<br/>
<details>
<summary>
❓자바에서 스레드를 사용하며 발생할 수 있는 문제와 해결하는 방법을 설명해주세요.
</summary>

스레드를 사용하며 멀티 스레드 환경에서 발생할 수 있는 문제는 Race Condition이 있는데,
Race Condition은 여러 개의 스레드가 하나의 자원을 놓고 서로 사용하려고 경쟁하는 상황
-> Deadlock 또는 Starvation 문제가 발생할 수 있음

<해결 방법>

- synchronized: synchronized 키워드를 통해 해당 블럭의 액세스를 동기화 할 수 있다.

- volatile: volatile 키워드를 통해 동일 시점에 모든 스레드가 동일한 값을 가지도록 동기화한다.
  하지만 volatile을 통해 모든 동기화 문제가 해결되진 않는다.
  ex) ++ 연산과 같이 원자성이 보장되지 않는 경우 동시성 문제는 다시 발생한다.

- Atomic 클래스: 위에 두 키워드 만으로는 동시성 문제를 깔끔하게 해결할 수 없는데,
  자바에서는 위 문제들을 해결하기 위해 비원자적 연산에서도 동기화를 빠르고 쉽게 이용할 수 있게 해주는 클래스 모음을 제공함(java.util.concurrent.\*)

</details>
<br/>
<details>
<summary>
❓추상 클래스와 인터페이스는 각각 언제 사용해야할까요?
</summary>

- 추상 클래스는 공통된 기능을 구현하는 일반 메서드를 제공하고, 하위 클래스에서 구현해야 하는 추상 메서드를 정의하여 필요한 메서드만을 하위에서 정의할 때 사용한다.
- 인터페이스는 다중상속이나 서로 다른 클래스에서 공통된 동작을 보장하고 싶을 때 사용한다.
</details>
<br/>
<details>
<summary>
❓ 자바에서의 멀티스레드 동기화에 대해 아는 대로 설명해주세요.
</summary>

- **`synchronized` 키워드**

  - synchronized가 적용된 코드 영역을 critical section으로 지정해 하나의 스레드만 접근할 수 있도록 막는 방식이다.
  - lock을 활용해 동기화한다.
  - 메소드에 붙여서 사용하거나, 블록에 붙여 동기화 블록을 만들 수도 있다.
  - 단, 스레드가 많아질 경우 다른 스레드들이 너무 오래 기다리는 등의 병목 현상으로 인해 자원 낭비가 발생할 수 있다.
    ![cpu-cache-coherence-and-java-concurrency-1](https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/f414c7ef-4991-4e33-afed-2aab05fc6c20)

- **`volatile` 키워드**

  - 그림과 같은 구조로 이루어지는 Java에서, Cache Memory를 사용하지 않고 Main Memory를 바로 사용하도록 함
  - 각 스레드마다 읽는 Cache가 다르기 때문에 서로 다른 Cache에서 읽어오는 경우 변수 불일치가 나타날 수 있어 이를 방지하고자 사용하는 방식
  - 가시성 문제는 해결하나 원자성이 보장되지 않는 경우 동시성 문제 해결 불가능

- **`Atomic` 클래스**

  - CAS 알고리즘을 사용해 원자성을 보장하는 클래스
    - CAS(Compare-And-Swap) : 현재 스레드가 존재하는 CPU의 Cache와 Main Memory에 저장된 값을 비교하고 일치할 때만 값을 교체하고, 다르면 실패하고 계속 재시함

- **`Semaphore` 클래스**

Java에서 제공하는 Semaphore 클래스를 사용해 구현 가능하다.

</details>
<br/>
<details>
<summary>
❓ 자바의 스레드풀(Thread Pool)은 무엇이고 구조가 어떻게 되나요? 자바는 왜 스레드풀을 사용할까요?
</summary>

- 스레드풀이란 자바에서 스레드들을 관리하는 방법
- Producer-Consumer 컨셉을 생각하면 이해하기 쉬움
- 전체 구조
  - 스레드풀에는 여러 스레드들이 미리 생성된 상태로 대기하고 있다.
    - 즉, 프로그램에서 생성 요청을 무한대로 한다고 해서 그만큼의 스레드가 생성되지 않는다.
  - 어플리케이션은 멀티 스레드로 처리해야할 작업을 작업 큐에 넣는다.
  - 스레드풀에서 대기중인 스레드들은 큐에 있는 작업을 꺼내 실행한다.
- 스레드를 너무 많이 생성하거나, 생성-해제를 반복하는 것은 시간적으로나 메모리적으로나 오버헤드가 매우 큰 작업이다.
  - 따라서, 적정 개수의 스레드를 스레드풀에 미리 생성해놓고, 위와 같은 방식으로 작업을 처리하는 게 스레드풀.
  - 스레드 생성-해제에 대한 오버헤드를 줄일 수 있다.
- 추가로 스레드마다 동일한 수의 task를 할당하는 것보다 스레드 풀을 활용하여 스레드에 task를 할당할 때, workload imbalance를 줄일 수 있다.

![다운로드](https://github.com/Shortudy-10th/tech-for-developer/assets/32262904/ce42931a-d2fc-4c1d-9215-922f6da7ea7a)

</details>

<br>

---
