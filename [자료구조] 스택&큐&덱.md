# Java 1일차

<details>

<summary>❓ 스택, 큐, 덱이 각각 어떠한 구조를 가지는지 설명해 주세요.</summary>

### ❓ 스택, 큐, 덱이 각각 어떠한 구조를 가지는지 설명해 주세요.

## 스택

![image](https://github.com/Shortudy-10th/tech-for-developer/assets/70586307/6f3322e2-4855-4193-9031-bee45a0a09bd)

* 단방향 자료구조로 LIFO(Last In First Out)의 구조를 가지고 있다. 마지막에 입력된 것이 먼저 삭제.

## 큐

![image](https://github.com/Shortudy-10th/tech-for-developer/assets/70586307/0392701a-8ee5-4f82-9bf1-2e2799959e7e)

* 단방향 자료구조로 FIFO(First In First Out)의 구조를 가지고 있음. 먼저 입력된 것이 먼저 삭제.

## 덱

![image](https://github.com/Shortudy-10th/tech-for-developer/assets/70586307/5986633c-c9d2-4ccb-88ed-d9c12ee3f543)

* 양방향 자료구조로 스택과 큐의 특징을 모두 가지고 있음. 양쪽 끝에서 삽입과 삭제가 모두 가능.

<details>

<summary>❓ 스택, 큐, 덱이 활용되는 알고리즘은 어떤 것들이 있나요?</summary>

## ❓ 스택, 큐, 덱이 활용되는 알고리즘은 어떤 것들이 있나요?

* 스택 : dfs

* 큐 : bfs

* 덱 : 슬라이딩 윈도우, 팰린드롬 판별

</details>


<details>

<summary>❓ 스택 오버플로우와 스택 언더플로우는 무엇이며, 어떻게 방지할 수 있나요? </summary>

## ❓ 스택 오버플로우와 스택 언더플로우는 무엇이며, 어떻게 방지할 수 있나요?

* 스택 오버플로우는 스택의 용량을 초과하여 데이터를 삽입하려는 경우 발생.
* 스택 언더플로우는 스택이 비어 있는데 데이터를 꺼내려는 경우 발생.'
* 이를 방지하기 위해서는 스택의 크기를 적절히 관리하고, 삽입/삭제 연산 전에 스택의 상태를 확인하는 로직을 추가해야 함.


</details>

</details>

<br>

---

<br>

<details>

<summary>❓ 스택, 큐, 덱을 프로그램상에서 구현한다면, 어떻게 구현할 수 있을까요?</summary>

### ❓ 스택, 큐, 덱을 프로그램상에서 구현한다면, 어떻게 구현할 수 있을까요?

<img src="https://github.com/seongeun42/cs-shortudy/assets/64778589/dfd07001-3e2f-43b1-99f7-581851feaf34" width="700"/>

* 배열, 연결리스트로 구현가능
  
* 스택
  * 배열
    * top 인덱스를 두어 맨 위 값을 판별한다.
    * push시 arr[++top] = data
    * peek시 arr not empty시 top을 반환
    * pop시 top값이 0이상이면 arr[top--] 반환
  * 연결리스트
    * 인덱스 대신 노드로 top을 구분한다.
    * push는 add 사용해서 그대로 넣기
    * pop은 pop(arr.size()-1)

 
* 큐
  * 배열
    * front 인덱스를 두어 pop할 때 참조하고, rear 인덱스를 두어 push할 때 넣을 위치를 참조한다.
    * enqueue시 rear 1씩 증가, arr[rear] = data
    * dequeue시 arr[front]를 반환해야 하고, front를 1씩 증가한다.
  * 연결리스트
    * 인덱스 대신 노드로 head와 tail을 두어 다음 노드를 구분한다.
    * enqueue는 addLast(data)
    * dequeue는 removeFirst()
      
* 덱
    * 배열
      * 기본적으로 큐랑 같다. 다만 front가 배열의 맨 뒤를 가리키고 rear가 배열의 맨 앞을 가리키는 형식.
      * 차이점은 appendLeft시 front가 --, appendRight시 rear++
      * popleft시 front가 ++, popright시 rear--
    * 연결리스트
      * 인덱스 대신 노드로 head와 tail을 두어 다음 노드를 구분한다.
      * appendLeft는 addFisrt() 앞으로 집어넣고, appendRight는 addLast() 뒤에다가 집어넣기.
      * popLeft는 pollFirst(), popright는 popLast() 이용
<details>     
<summary> 배열로 구현했을때 </summary> 
  
    * 장점
      * 접근 속도가 빠르다. 
      * 메모리에 연속적으로 할당되어 있어 캐시 효율성이 높다.
      * 고정된 크기로 메모리 관리가 간단하다.
      
    * 단점
      * 크기 조정이 어렵다.
      * 삽입 또는 삭제 시 다른 요소들을 이동해야 할 경우 오버헤드 발생 가능
      * 메모리 낭비 발생 가능   
</details>
<details>
<summary> 연결리스트로 구현했을때 </summary> 
  
    * 장점
      * 크기 조정이 가능하다. 
      * 삽입 삭제 시간이 빠르고, 요소 이동 X
      * 삽입, 삭제가 배열보다 유연하다.
      
    * 단점
      * 포인터를 사용하여 연결하기 때문에 메모리 오버헤드 발생 가능
      * 배열에 비해 느린 접근
      * 캐시 효율성이 낮다.  
</details>
</details>

<br>

---

<br>

<details>

<summary>❓ 스택과 큐의 특징과 이 둘은 어디에 주로 사용되나요?</summary>

### ❓ 스택과 큐의 특징과 이 둘은 어디에 주로 사용되나요?

<img src="https://github.com/seongeun42/cs-shortudy/assets/64778589/dfd07001-3e2f-43b1-99f7-581851feaf34" width="700"/>
  
* 스택
  * 스택의 가장 큰 특징은 먼저 들어간 값이 나중에 나온다는 것이다.
  * 이러한 특징을 가져 나중에 들어간 값이 먼저 나와야 하는 경우에 사용된다. 웹 브라우저 방문 기록, 역순 문자열 만들기, 실행 취소 등
  * 프로그래밍 언어는 호출된 함수 호출을 관리할 때 스택을 사용한다. 함수가 호출될 때마다 스택에 추가되고, 함수가 종료될 때 스택에서 제거된다.
  * 덕분에 재귀 함수 호출과 중첩 함수 호출도 가능하다.
  
![image](https://github.com/Shortudy-10th/tech-for-developer/assets/39663810/00b77600-ca6a-47b8-8468-90fc4205a022)
 
* 큐
  * 큐의 가장 큰 특징은 먼저 들어간 값이 먼저 나온다는 것이다.
  * 이러한 특징을 가져 데이터가 입력 순서대로 처리해야 할 필요가 있을 때 사용한다. 캐시, 프린터의 출력 처리, 메시지 큐, 웹 서버 요청처리 등
  * 운영체제에서 다수의 프로세스를 관리하기 위해 큐를 사용한다. 대기 중인 프로세스를 큐에 넣고 순서대로 처리한다. (물론 실제로는 훨씬 더 복잡하지만, 러프하게 보자면 이런 관점이라고 할 수 있다.)
  * 덕분에 시스템의 자원을 효율적으로 할당할 수 있다.
  
![image](https://github.com/Shortudy-10th/tech-for-developer/assets/39663810/8bbcc2bf-17d3-4b28-aded-7c4e7adaa207)

<details>
<summary> 덱의 특징과 어디에 주로 사용되나요? </summary>
  
* 덱
  * OS는 주로 스택, 큐, 힙과 같은 더 기본적인 자료구조를 사용하여 프로세스 관리, 스케줄링, 메모리 관리 등의 작업을 수행한다.
  * 따라서 사용자가 양방향으로 처리하고자 하는 다양한 로직에 활용하면 된다.
    * ex) 스크롤 기능 : 화면에 표시하고 싶은 객체나 데이터를 덱에 저장하여, 스크롤 이벤트에 따라 양방향으로 객체를 추가/삭제한다.
  * 덱의 예시로는 웹 브라우저에서의 탭 관리나, 음악 재생 목록, 슬라이딩 윈도우 알고리즘이 있다.
    * 슬라이딩 윈도우 알고리즘은 연속된 구간에서 최솟값이나 최댓값을 빠르게 구하는 데 활용
</details>
</details>

<br>

---

<br>

<details>

<summary>❓ 브라우저에서 스택과 큐는 언제 활용되고 있나요?</summary>

### ❓ 브라우저에서 스택과 큐는 언제 활용되고 있나요?

![img](https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/fc94bede-4e8b-47ad-81c3-659841fc64b1)

웹은 HTML, CSS, JavaScript로 작성하고, 웹브라우저는 이 문서들을 해석해 실행시켜준다.

그중 JavaScript 엔진은 내부적으로 메모리 힙(Memory Heap)과 콜 스택(Call Stack)을 가지고 있는데, 메모리 힙은 메모리 할당이 이루어지는 곳이고, 콜 스택은 코드 실행에 따라 함수 호출 스택이 쌓이는 곳이다. 콜 스택은 이름 그대로 스택 구조이므로, 가장 마지막에 쌓인 코드를 먼저 수행하게 된다.

단, JavaScript는 기본적으로 싱글 스레드 기반 언어이므로, 콜 스택을 하나만 가지고 있으며 한 번에 하나의 작업만 처리할 수 있다. 하지만 이로 인해 하나의 작업이 끝날 때까지 나머지 작업들이 계속 대기하면 프로그램이 매우 느려질 수 있기 때문에, 이벤트 루프와 브라우저에 존재하는 Web API 같은 백그라운드 공간, 태스크 큐 등을 통해 비동기 방식을 실현한다. 우선 바로 실행할 수 있는 코드만 먼저 수행하고 setTimeout과 같이 비동기로 실행되는 것들은 해당 함수의 콜백함수와 타이머가 백그라운드 공간으로 옮겨진다. 이후 타이머가 만료되면 태스크 큐에 넣어진다. 이후 콜 스택이 전부 비게 되면 태스크 큐에 들어온 순서대로 콜 스택으로 옮겨져 실행된다.

</details>

<br>
