# 운영체제 - CPU 스케줄링

<details>

<summary>❓ CPU 스케줄러는 무엇인가요?</summary>

### ❓ CPU 스케줄러는 무엇인가요?

<br>

* **CPU 스케줄러란?**

  컴퓨터의 중앙처리장치(CPU)가 여러 프로세스들 간에 어떤 순서로 실행될지 결정하는 컴퓨터 운영체제의 핵심 구성 요소
  
  ![image](https://github.com/Shortudy-10th/tech-for-developer/assets/32262904/44dc4509-e993-4bc1-988d-8fff2fba6f67)
  
  다양한 요소를 고려해 프로세스 스케줄링을 수행하며 프로세스 상태를 변화시킴


<br>


* **CPU 스케줄러가 하는 역할**

  * 프로세스 스위칭 관리
    * 프로세스의 스위칭을 관리하고 효율적을 수행함
  * 우선순위 결정
    *  프로세스의 우선순위에 따라 어떤 프로세스을 먼저 실행할지 결정함
  * 공정한 자원 할당
    * 모든 프로세스가 공정하게 CPU를 할당받도록 관리함
  * 응답 시간 최적화
    * 사용자와 상호작용하는 프로세스에 대한 빠른 응답 시간을 보장하기 위해 CPU 스케줄링을 조정함



</details>

<br>

---

<br>

<details>

<summary>❓ CPU 스케줄링의 성능 척도에는 어떤 것들이 있나요?</summary>

### ❓ CPU 스케줄링의 성능 척도에는 어떤 것들이 있나요?

<br>

CPU 스케줄링의 성능 척도는 크게 시스템 관점과 사용자 관점으로 나뉜다.

### 시스템 관점
성능 척도  | 설명
--    | --
**CPU 이용률** | CPU가 쉬지 않고 일한 시간의 비율. 높을 수록 좋다. CPU 스케줄링에 따라 이용률이 변경될 수 있음
**처리량(Throughput)** | 단위시간당 처리량. 시스템 입장에서 얼마나 많은 일을 했는가를 나타내며 높을수록 좋다

### 사용자 관점
성능 척도 | 설명
-- | --
**소요시간, 반환시간** | CPU burst에 들어와서, I/O burst가 될 때까지의 전체 시간의 합. Ready Queue에서 기다린 시간 + 실제로 CPU를 사용한 시간
**대기시간** | CPU를 사용하기 위해 기다린 전체 시간의 합. CPU burst에 들어와서 프로세스는 CPU를 얻고 뺏기를 반복하는 데, I/O burst 상태에 되기 직전까지 Ready Queue에서 CPU 사용을 위해 기다린 전체 시간의 합
**응답 시간** | 특정 프로세스가 CPU를 사용하기 위해 들어와서 CPU를 최초로 사용하기까지 걸리는 시간. CPU burst로 들어와 최초로 CPU를 얻기까지 걸리는 시간. 대부분의 프로세스는 preemptive이므로 이 시간이 응답 시간으로 측정됩니다.


+) 응답시간, 대기시간, 반환시간, 실행시간

<img src="https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/15a79824-d2c5-4060-a003-fc079f1500d0" width="800">

</details>

<br>

---

<br>

<details>

<summary>❓ 운영체제가 스케줄링 결정을 내리는 시점과 방식에 대해 설명해주세요.</summary>

### ❓ 운영체제가 스케줄링 결정을 내리는 시점과 방식에 대해 설명해주세요.

<br>

- **스케줄링 결정 시점 -> CPU 점유 프로세스를 다른 프로세스로 전환할 때**
  * **프로세스 생성**: 새로운 프로세스가 생성되거나 실행 가능한 상태로 변경될 때, 운영체제는 이 프로세스에 CPU를 할당할지 여부를 결정한다.
  
  * **프로세스 종료**: 프로세스가 종료되면 해당 프로세스에 할당된 CPU 자원을 반환하고, 다음으로 실행될 프로세스를 선택한다.
  
  * **인터럽트 및 시그널**: 외부 이벤트나 프로세스 내부에서 발생한 인터럽트 또는 시그널에 응답하여, 운영체제는 현재 실행 중인 프로세스를 일시 중단하고 다른 프로세스로 전환할 수 있다.
  
  * **시간 할당량 초과**: CPU 할당 시간이 만료된 경우, 해당 프로세스는 준비 상태로 이동하고 다른 프로세스에게 CPU를 할당한다.
  
  * **I/O 요청**: 프로세스가 I/O 작업을 요청하면, 해당 프로세스는 대기 상태로 전환되고, 다른 실행 가능한 프로세스가 CPU를 할당 받는다.
  
  * **우선순위 변경**: 프로세스의 우선순위가 변경되거나, 운영체제가 더 높은 우선순위의 프로세스에게 CPU를 할당하도록 결정할 수 있다.

<br>

- **스케줄링 방식**
  - **선점형 스케줄링**
    -  프로세스가 실행 중에 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 방식
    -  시간 할당량이나 우선순위에 따라 프로세스를 전환
    -  Round Robin, Priority Scheduling 등
  
  - **비선점형 스케줄링**
    -  프로세스가 CPU를 스스로 반납하기 전까지 실행을 계속할 수 있는 스케줄링 방식
    -  프로세스가 끝나거나 I/O 요청을 하면 CPU를 반환
    -  FCFS (First-Come, First-Served), SJF (Shortest Job First)

</details>

<br>

---

<br>

<details>

<summary>❓ 스케줄링의 목적과 저, 중, 고수준 단계에 대해 말해주세요.</summary>

### ❓ 스케줄링의 목적과 저, 중, 고수준 단계에 대해 말해주세요.

<br>

- **스케줄링의 목적**

  |**목적**||
  |---|---|
  |**공평성**|모든 프로세스가 자원을 공평하게 배정받아야 하며, 특정 프로세스가 배제되어서는 안 됨|
  |**효율성**|시스템 자원을 놀리는 시간 없이 스케줄링해야 함|
  |**안정성**|우선순위를 사용하여 중요한 프로세스가 먼저 처리되도록 해야 함|
  |**반응 시간 보장**|응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 함|
  |**무한 연기 방지**|특정 프로세스의 작업이 무한히 연기되어서는 안 됨|

<br>

- **단계별 스케줄링**

  <img src="https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/1fc0d4c8-d7f9-4a2c-a3e7-9b9b61aad212" width="550">
  
  * **고수준 스케줄링**
     * long-term scheduling, job scheduling, admission scheduling
     * 가장 큰 틀에서 이루어지는 CPU 스케줄링으로 **시스템 내의 전체 작업 수를 조절**
     *  시스템 과부하를 막기 위해 어떤 작업을 시스템이 받아들일지 또는 거부할지를 결정하므로 시스템 내에서 동작 시에 실행 가능한 프로세스의 총개수가 정해짐
     * 새로운 작업을 시스템에 추가하거나, 현재 실행 중인 작업들 간의 우선순위를 조정하거나 변경할 때 사용
     * 주로 메인프레임 같은 큰 시스템에서 규모가 큰 일괄 작업을 처리할 때 사용함
  * **중간 수준 스케줄링**
     * 중지(suspend)와 활성화(active)로 **전체 시스템의 활성화된 프로세스 수를 조절함**
       * 프로세스가 활성화된 후에도 여러 요인으로 시스템 과부하가 걸릴 수 있기 때문
     * 이로 인해 저수준 스케줄링이 원만하게 이루어지도록 완충하는 역할을 함
     * 보류된 프로세스는 여유가 생기면 다시 활성화됨
     * 스왑아웃(메모리에 적재된 프로세스를 디스크로 옮기는 작업) 및 스왑인(디스크에 저장된 프로세스를 메모리로 다시 로드하는 작업) 작업을 통해 메모리에 적재될 프로세스를 결정하고 메모리 공간을 확보함
  * **저수준 스케줄링**
     * short-term scheduling
     * 가장 작은 단위의 스케줄링으로 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정
     * 중간 수준의 스케줄링은 프로세스를 보류 상태로 보내고, 저수준 스케줄링은 대기 상태로 보냄
     * **스케줄링에 대해 공부하는 대부분의 내용이 이 저수준 스케줄링**
       * 즉, 준비 상태 <-> 실행 상태 <-> 대기 상태 등 프로세스의 상태 변화가 여기서 일어남

</details>

<br>

---

<br>

<details>

<summary>❓ 스케줄러가 어떤 프로세스에 우선적으로 CPU를 할당할지 스케줄링 시 고려하는 사항에 대해 말해주세요.</summary>

### ❓ 스케줄러가 어떤 프로세스에 우선적으로 CPU를 할당할지 스케줄링 시 고려하는 사항에 대해 말해주세요.

<br>

* **preemptive vs non-preemptive**
   * 선점형 스케줄링 : 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 방식
      * CPU 처리 시간이 매우 긴 프로세스가 CPU 사용 독점을 막을 수 있어 효율적인 운영이 가능
      * 하지만 잦은 Context Switching 으로 오버헤드가 많이 발생
   * 비선점형 스케줄링 : 프로세스가 CPU를 점유하고 있다면 이를 빼앗을 수 없는 방식
      * 필요한 문맥 교환만 일어나기 때문에 오버헤드가 상대적으로 적지만 프로세스의 배치에 따라 효율성 차이가 많이 남

* **CPU bound vs I/O bound**
   * 프로세스가 대기 상태에 있다가 CPU를 할당받아 실행하면 CPU burst, 입출력 작업을 하면 I/O burst
   * CPU bound process(CPU 집중 프로세스) : CPU를 많이 사용하여 CPU burst가 많은 프로세스
   * I/O bound process(입출력 집중 프로세스) : 입출력을 많이 사용해 I/O burst가 많은 프로세스
   * 두 프로세스가 같이 대기상태에 있다면 입출력 집중 프로세스에 먼저 CPU를 할당시키는 것이 더 효율적
      * 왜냐하면 입출력 집중 프로세스는 CPU를 빠르게 쓰고 입출력 버스트를 하러 나가기 때문에 다른 프로세스가 오래 기다리지 않아도 됨

* **전면 프로세스 vs 후면 프로세스**
   * 전면 프로세스 : GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓여 현재 입출력이 사용됨
      *  사용자와 상호작용이 가능해 상호작용 프로세스라고도 불림 (워드 프로세스)
   * 후면 프로세스 : 사용자의 입력 없이 작동하여 일괄 작업 프로세스라고 불림 (압축 프로세스)
   * 전면 프로세스는 사용자의 요구에 즉각 즉각 반응해야 하지만 후면 프로세스는 그럴 필요가 없음
      *  따라서 전면 프로세스를 먼저 처리해 줘야 함

<br>

* **프로세스 우선순위**

  ![image](https://github.com/Shortudy-10th/tech-for-developer/assets/64778589/e98875a7-6513-427e-8cfe-17608f1292f9)
   * CPU 스케줄러 대부분은 프로세스에 우선순위를 매겨 우선순위가 높은(우선순위 숫자가 작은) 프로세스부터 처리되도록 함

</details>

<br>
